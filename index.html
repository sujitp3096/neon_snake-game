<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Snake Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the Neon Effect and Game Board */
        body {
            background-color: #0d1117; /* Dark background */
            font-family: 'Inter', sans-serif;
        }
        #game-board {
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.3);
            background-color: #161b22; /* Slightly lighter dark for the board */
            border: 2px solid #0ff; /* Neon border */
            border-radius: 10px;
        }
        .snake-segment {
            background-color: #0ff; /* Neon blue */
            border-radius: 2px;
            box-shadow: 0 0 5px #0ff;
        }
        .food {
            background-color: #ff00ff; /* Neon magenta */
            border-radius: 50%;
            box-shadow: 0 0 8px #ff00ff;
        }
        /* Mobile Controls Styling */
        .control-button {
            transition: all 0.1s;
            box-shadow: 0 4px #00aaff;
            background-color: #00bfff;
        }
        .control-button:active {
            box-shadow: 0 1px #00aaff;
            transform: translateY(3px);
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-center min-h-screen">

    <div class="max-w-md w-full">
        <!-- Header and Score -->
        <h1 class="text-4xl font-extrabold text-[#0ff] text-center mb-4 tracking-wider">
            NEON SNAKE
        </h1>
        <div id="status-bar" class="flex justify-between p-3 mb-4 rounded-lg bg-[#161b22] border border-[#0ff] shadow-lg shadow-[#0ff]/20">
            <span class="text-xl text-white">Score: <span id="score">0</span></span>
            <span class="text-xl text-white">High Score: <span id="high-score">0</span></span>
        </div>

        <!-- Game Board Container -->
        <div id="game-container" class="relative aspect-square w-full">
            <div id="game-board" class="w-full h-full grid relative">
                <!-- Game elements will be injected here by JavaScript -->
            </div>
            
            <!-- Start/Game Over Overlay -->
            <div id="overlay" class="absolute inset-0 bg-black/80 rounded-lg flex flex-col items-center justify-center transition-opacity duration-300">
                <h2 id="overlay-message" class="text-3xl font-bold text-[#ff00ff] mb-6 text-center">
                    Welcome to Neon Snake!
                </h2>
                <button id="start-button" class="px-6 py-3 text-xl font-bold text-black rounded-lg bg-[#0ff] hover:bg-[#00ffff] transition-colors shadow-xl shadow-[#0ff]/50">
                    Start Game
                </button>
                <p class="text-white mt-4 text-center">Use *Arrow Keys* or *Mobile Buttons* to play.</p>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls" class="mt-6 p-4 rounded-xl bg-[#161b22] border border-[#0ff] md:hidden">
            <div class="flex justify-center">
                <!-- UP Button -->
                <button data-direction="up" class="control-button px-6 py-3 rounded-t-lg mx-1 text-white font-bold text-2xl">
                    &uarr;
                </button>
            </div>
            <div class="flex justify-between my-2">
                <!-- LEFT Button -->
                <button data-direction="left" class="control-button px-6 py-3 rounded-l-lg mx-1 text-white font-bold text-2xl">
                    &larr;
                </button>
                <!-- DOWN Button -->
                <button data-direction="down" class="control-button px-6 py-3 rounded-lg mx-1 text-white font-bold text-2xl">
                    &darr;
                </button>
                <!-- RIGHT Button -->
                <button data-direction="right" class="control-button px-6 py-3 rounded-r-lg mx-1 text-white font-bold text-2xl">
                    &rarr;
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- High Score Logic (using localStorage only) ---
        let highScore = 0;

        /**
         * Loads the high score from the browser's local storage.
         */
        function loadHighScore() {
            highScore = parseInt(localStorage.getItem('snakeHighScore') || '0', 10);
            document.getElementById('high-score').textContent = highScore;
        }

        /**
         * Updates the high score if the new score is higher.
         * @param {number} newScore 
         */
        function updateHighScore(newScore) {
            if (newScore > highScore) {
                highScore = newScore;
                document.getElementById('high-score').textContent = highScore;
                localStorage.setItem('snakeHighScore', highScore);
            }
        }


        // --- Game Logic Variables ---

        const board = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score');
        const overlay = document.getElementById('overlay');
        const overlayMessage = document.getElementById('overlay-message');
        const startButton = document.getElementById('start-button');
        const mobileControls = document.getElementById('mobile-controls');

        const GRID_SIZE = 20;
        const CELL_SIZE = 1; // Used for dynamic grid sizing

        let snake = [];
        let food = {};
        let direction = { x: 0, y: 0 };
        let nextDirection = { x: 1, y: 0 }; // Initial movement is right
        let gameLoopInterval;
        let gameSpeed = 150; // Initial speed in ms
        let currentScore = 0;

        // --- Utility Functions ---

        /**
         * Converts grid coordinates to a unique string key for easy DOM manipulation.
         * @param {number} x 
         * @param {number} y 
         * @returns {string}
         */
        const getCellKey = (x, y) => cell-${x}-${y};

        /**
         * Sets up the initial CSS Grid on the game board element.
         */
        function setupGrid() {
            board.style.gridTemplateColumns = repeat(${GRID_SIZE}, ${CELL_SIZE}fr);
            board.style.gridTemplateRows = repeat(${GRID_SIZE}, ${CELL_SIZE}fr);
            board.innerHTML = ''; // Clear existing content
        }

        /**
         * Draws an element (snake segment or food) onto the board.
         * @param {{x: number, y: number}} position 
         * @param {string} className 
         */
        function drawElement(position, className) {
            const cellElement = document.createElement('div');
            cellElement.style.gridRowStart = position.y + 1;
            cellElement.style.gridColumnStart = position.x + 1;
            cellElement.classList.add(className);
            cellElement.id = getCellKey(position.x, position.y);
            board.appendChild(cellElement);
        }

        /**
         * Generates a random position within the grid boundaries that is not occupied by the snake.
         * @returns {{x: number, y: number}}
         */
        function getRandomPosition() {
            let newPosition;
            do {
                newPosition = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
            } while (snake.some(segment => segment.x === newPosition.x && segment.y === newPosition.y));
            return newPosition;
        }

        /**
         * Places the food item on the board.
         */
        function placeFood() {
            // Remove old food element from DOM if it exists
            const oldFoodElement = document.querySelector('.food');
            if (oldFoodElement) {
                oldFoodElement.remove();
            }

            food = getRandomPosition();
            drawElement(food, 'food');
        }

        /**
         * Initializes the game state.
         */
        function initGame() {
            setupGrid();
            snake = [{ x: 10, y: 10 }];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            currentScore = 0;
            gameSpeed = 150;

            scoreDisplay.textContent = currentScore;
            
            // Draw the initial snake
            snake.forEach(segment => drawElement(segment, 'snake-segment'));

            placeFood();
        }

        /**
         * The main game loop function.
         */
        function gameLoop() {
            // Apply the direction change stored in nextDirection
            direction = nextDirection;
            
            const head = snake[0];
            const newHead = { x: head.x + direction.x, y: head.y + direction.y };

            // 1. Check for Game Over
            if (isGameOver(newHead)) {
                endGame();
                return;
            }

            // Add the new head to the front of the snake
            snake.unshift(newHead);
            drawElement(newHead, 'snake-segment');

            // 2. Check for Food Collision
            if (newHead.x === food.x && newHead.y === food.y) {
                // Food eaten: grow snake and place new food
                currentScore += 10;
                scoreDisplay.textContent = currentScore;
                
                // Increase speed for challenge (up to a limit)
                gameSpeed = Math.max(50, gameSpeed - 3);
                clearInterval(gameLoopInterval);
                gameLoopInterval = setInterval(gameLoop, gameSpeed);

                // Remove old food element from DOM
                const oldFoodElement = document.getElementById(getCellKey(food.x, food.y));
                if (oldFoodElement) {
                    oldFoodElement.remove();
                }

                placeFood();
            } else {
                // No food eaten: remove tail
                const tail = snake.pop();
                const tailElement = document.getElementById(getCellKey(tail.x, tail.y));
                if (tailElement) {
                    tailElement.remove();
                }
            }
        }

        /**
         * Checks if the game should end based on the snake's new head position.
         * @param {{x: number, y: number}} newHead 
         * @returns {boolean}
         */
        function isGameOver(newHead) {
            // Check wall collision
            if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE) {
                return true;
            }

            // Check self-collision (starts checking from segment 1, skipping head 0)
            for (let i = 1; i < snake.length; i++) {
                if (newHead.x === snake[i].x && newHead.y === snake[i].y) {
                    return true;
                }
            }

            return false;
        }

        /**
         * Ends the game and shows the overlay.
         */
        function endGame() {
            clearInterval(gameLoopInterval);
            updateHighScore(currentScore);
            overlayMessage.textContent = Game Over! Your Score: ${currentScore};
            overlay.classList.remove('opacity-0', 'pointer-events-none');
            startButton.textContent = 'Play Again';
        }

        /**
         * Starts or resumes the game.
         */
        function startGame() {
            overlay.classList.add('opacity-0', 'pointer-events-none');
            initGame();
            gameLoopInterval = setInterval(gameLoop, gameSpeed);
        }

        // --- Event Handlers ---

        startButton.addEventListener('click', startGame);

        /**
         * Handles keyboard input to change the snake's direction.
         * @param {KeyboardEvent} event 
         */
        document.addEventListener('keydown', (event) => {
            // Only allow input if the overlay is hidden (game is running)
            if (overlay.classList.contains('opacity-0')) {
                 setNextDirection(event.key);
            } else if (event.key === 'Enter') {
                startGame();
            }
        });

        /**
         * Handles mobile touch/click input for direction.
         * @param {MouseEvent} event 
         */
        mobileControls.querySelectorAll('.control-button').forEach(button => {
            button.addEventListener('click', (event) => {
                // Only allow input if the overlay is hidden (game is running)
                if (overlay.classList.contains('opacity-0')) {
                    const directionKey = event.currentTarget.getAttribute('data-direction');
                    setNextDirection(directionKey);
                }
            });
        });

        /**
         * Central function to set the next desired direction, preventing 180 degree turns.
         * @param {string} key 
         */
        function setNextDirection(key) {
            let dirX = 0;
            let dirY = 0;
            
            switch (key) {
                case 'ArrowUp':
                case 'up':
                    dirY = -1;
                    break;
                case 'ArrowDown':
                case 'down':
                    dirY = 1;
                    break;
                case 'ArrowLeft':
                case 'left':
                    dirX = -1;
                    break;
                case 'ArrowRight':
                case 'right':
                    dirX = 1;
                    break;
                default:
                    return;
            }
            
            // Get the current direction the snake is heading
            const currentDir = direction;

            // Prevent turning 180 degrees (e.g., if currently moving right (x=1), don't allow moving left (x=-1))
            if (dirX !== -currentDir.x && dirY !== -currentDir.y) {
                // If the new direction is horizontal and the current direction is vertical (or vice versa), it's a valid turn.
                if ((dirX !== 0 && currentDir.y !== 0) || (dirY !== 0 && currentDir.x !== 0)) {
                    nextDirection = { x: dirX, y: dirY };
                }
                // If both are non-zero (diagonal), or both zero (no move), do nothing.
                // If both are horizontal or both vertical (i.e., continuing straight), update direction.
                else if (dirX !== 0 && currentDir.x !== 0) {
                    nextDirection = { x: dirX, y: dirY };
                } else if (dirY !== 0 && currentDir.y !== 0) {
                    nextDirection = { x: dirX, y: dirY };
                }
            }
        }

        // Initial setup when the page loads
        window.onload = function() {
            setupGrid();
            loadHighScore(); // Load the score immediately
        };

    </script>
</body>
</html>

